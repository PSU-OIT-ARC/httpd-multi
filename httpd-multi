#!/usr/bin/env python
from __future__ import print_function
import time
from collections import defaultdict
import subprocess
import re
import os
import sys
import signal
import socket

# path to the httpd executable
HTTPD = "/usr/sbin/httpd"
# path to the apache base configuration you want to use relative to serverroot
BASE_CONF = "base.conf"
# path to the vhost directory
VHOST_DIR = "/etc/httpd/vhost.d"
# the suffix on the files we want to parse to create an additional instances of
# apache for
VHOST_SUFFIX = ".vhost"
# a name to use for pid files so we know which ones belong to us
IDENTIFIER = "httpdmulti"
# where to store pid files
PID_DIR = "/var/run/httpd"
# this is the name of the generated vhost that proxies to all the other
# instances of apache
PROXY_VHOST_NAME = "0proxy.conf"
# the vhost template to use when proxying
VHOST_PROXY_TEMPLATE = """
<VirtualHost *:80>
    ProxyPreserveHost on
    ProxyPass / http://localhost:%(port)d/ retry=0
    ProxyPassreverse / http://localhost:%(port)d/
    %(directives)s 
</VirtualHost>
"""

def get_open_port():
    """Returns an open port number"""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("",0))
    port = s.getsockname()[1]
    s.close()
    return port


def pidof(binary):
    """Returns a set of pid numbers that are currently running the binary"""
    proc = subprocess.Popen(['pidof', binary], stdout=subprocess.PIPE)
    return set(int(pid) for pid in proc.stdout.read().strip().split(" "))


def try_remove(path):
    """Tries to remove the file at path"""
    try:
        os.remove(path)
        return True
    except OSError:
        return False


def try_kill(pid, sig):
    """Sends the sig signal to the pid""" 
    try:
        os.kill(pid, sig)
        return True
    except OSError:
        return False


def killproc(pid_file, binary, max_tries=10):
    """
    Emulates the killproc /etc/init.d function. Sends a SIGTERM signal to the
    process in pid_file, assuming the binary matches the pid. Waits a maximum
    of max_tries seconds, and then SIGKILLS the process.
    """
    try:
        pid = int(open(pid_file).read().strip())
    except (TypeError, ValueError, OSError) as e:
        return 1 # couldn't open the pid file

    # first send the SIGTERM signal
    if pid in pidof(binary):
        try_kill(pid, signal.SIGTERM)
        # give the process a little bit of time to clean up
        time.sleep(0.1)
    else:
        try_remove(pid_file)
        return 2 # the process wasn't running

    # now ensure we killed the process
    tries = 0
    while tries < max_tries:
        if pid in pidof(binary):
            time.sleep(1)
            tries += 1
        else:
            try_remove(pid_file)
            return 0

    # as a last resort...
    try_kill(pid, signal.SIGKILL)
    try_remove(pid_file)
    return 0


def cleanup(excluding):
    """
    Finds the pid files in PID_DIR and kills'em off, except for the files that
    are in excluding
    """
    for pid_file in os.listdir(PID_DIR):
        pid_file = os.path.join(PID_DIR, pid_file)
        if os.path.basename(pid_file).startswith(IDENTIFIER) and pid_file not in excluding:
            killproc(pid_file, HTTPD)


if __name__ == "__main__":
    # record a set of all the pid files we've created, so we know which ones *not* to
    # clean up later
    pid_files = set()

    # loop through all the vhosts ending in .vhost and extract the ServerName
    # and ServerAlias lines. For each vhost file, construct a vhost that
    # proxies to it from port 80
    proxy_vhosts = []
    for filename in os.listdir(VHOST_DIR):
        port = get_open_port()
        # ignore non-.vhost files
        if not filename.endswith(VHOST_SUFFIX):
            continue

        # record all the ServerName and ServerAlias lines in the vhost
        server_name_alias_directives = []
        vhost_path = os.path.join(VHOST_DIR, filename)
        with open(vhost_path, "r") as vhost:
            for line in vhost:
                line = line.strip()
                # did the line match?
                matches = re.search(r"^\s*(ServerName|ServerAlias)", line, re.IGNORECASE)
                if not matches:
                    continue

                server_name_alias_directives.append(line)

        pid_file = os.path.join(PID_DIR, "%s-%s-%d.pid" % (IDENTIFIER, filename, port))
        cmd = [
            HTTPD, 
            "-f", BASE_CONF,
            "-Dhttpdmulti",
            "-C", 'User apache',
            "-C", 'Group apache',
            "-c", 'Include %s' % vhost_path,
            "-c", 'Listen %d' % port,
            "-c", 'PidFile %s' % pid_file,
        ] + sys.argv[1:]
        print(subprocess.list2cmdline(cmd))
        code = subprocess.call(cmd) 
        if code == 0:
            pid_files.add(pid_file)
            proxy_vhosts.append(VHOST_PROXY_TEMPLATE % {"port": port, "directives": "\n".join(server_name_alias_directives)})
   
    # now create a vhost file that combines all the proxy vhosts we created
    with open(os.path.join(VHOST_DIR, PROXY_VHOST_NAME), "w") as f:
        f.write("# This is generated. Do not edit. See httpd-multi script\n")
        f.write("\n".join(proxy_vhosts))

    # run the command first using the base httpd process
    cmd = [HTTPD] + sys.argv[1:]
    print(subprocess.list2cmdline(cmd))
    subprocess.call(cmd)

    cleanup(pid_files)
