#!/usr/bin/env python
from __future__ import print_function
import time
import subprocess
import re
import os
import sys
import signal
import socket
import errno

# path to the httpd executable
HTTPD = "/usr/sbin/httpd"
# path to the vhost directory
VHOST_DIR = "/etc/httpd/vhost.d"
# the suffix on the files we want to parse to create an additional instances of
# apache for
VHOST_SUFFIX = ".vhost"
# a name to use for pid files so we know which ones belong to us
IDENTIFIER = "httpdmulti"
# where to store pid files. This dir should not be writable except by root
# since it would allow someone to SIGKILL any process otherwise
PID_DIR = "/var/run/httpd"
# this is the name of the generated vhost that proxies to all the other
# instances of apache
PROXY_VHOST_NAME = "main-conf.d/httpd-multi-proxies.conf"
# port range for proxied vhosts
VHOST_PROXY_PORT_START = 9000
# the vhost template to use when proxying
VHOST_PROXY_TEMPLATE_HTTPS = """
<IfDefine !httpdmulti>
    <VirtualHost *:80>
        RewriteEngine on
        RewriteCond %%{HTTPS} off
        RewriteRule (.*) https://%%{HTTP_HOST}%%{REQUEST_URI} [R=301]
        %(directives)s
    </VirtualHost>

    <VirtualHost *:443>
        SSLEngine on
        SSLCertificateFile /etc/pki/tls/certs/stage.rc.pdx.edu.crt
        SSLCertificateKeyFile /etc/pki/tls/private/stage.rc.pdx.edu.key
        SSLProtocol -ALL +TLSv1 +TLSv1.1 +TLSv1.2

        ProxyPreserveHost on
        ProxyPass / http://localhost:%(port)d/ retry=0
        ProxyPassreverse / http://localhost:%(port)d/
        RequestHeader set X-Forwarded-Proto "https"

        %(directives)s
    </VirtualHost>
</IfDefine>
"""

VHOST_PROXY_TEMPLATE_HTTP = """
<IfDefine !httpdmulti>
    <VirtualHost *:80>
        ProxyPreserveHost on
        ProxyPass / http://localhost:%(port)d/ retry=0
        ProxyPassreverse / http://localhost:%(port)d/

        %(directives)s
    </VirtualHost>
</IfDefine>
"""


def pidof(binary):
    """Returns a set of pid numbers that are currently running the binary"""
    proc = subprocess.Popen(['pidof', binary], stdout=subprocess.PIPE)
    return set(int(pid) for pid in proc.stdout.read().strip().split(" "))


def try_remove(path):
    """Tries to remove the file at path"""
    try:
        os.remove(path)
        return True
    except OSError:
        return False


def try_kill(pid, sig):
    """Sends the sig signal to the pid""" 
    try:
        os.kill(pid, sig)
        return True
    except OSError:
        return False


def killproc(pid_file, binary, max_tries=10):
    """
    Emulates the killproc /etc/init.d function. Sends a SIGTERM signal to the
    process in pid_file, assuming the binary matches the pid. Waits a maximum
    of max_tries seconds, and then SIGKILLS the process.
    """
    try:
        pid = int(open(pid_file).read().strip())
    except (TypeError, ValueError, OSError) as e:
        return 1 # couldn't open the pid file

    # first send the SIGTERM signal
    if pid in pidof(binary):
        try_kill(pid, signal.SIGTERM)
        # give the process a little bit of time to clean up
        time.sleep(0.1)
    else:
        try_remove(pid_file)
        return 2 # the process wasn't running

    # now ensure we killed the process
    tries = 0
    while tries < max_tries:
        if pid in pidof(binary):
            time.sleep(1)
            tries += 1
        else:
            try_remove(pid_file)
            return 0

    # as a last resort...
    try_kill(pid, signal.SIGKILL)
    try_remove(pid_file)
    return 0


def cleanup(excluding):
    """
    Finds the pid files in PID_DIR and kills'em off, except for the files that
    are in excluding
    """
    for pid_file in os.listdir(PID_DIR):
        pid_file = os.path.join(PID_DIR, pid_file)
        if os.path.basename(pid_file).startswith(IDENTIFIER) and pid_file not in excluding:
            killproc(pid_file, HTTPD)


class VHostFile:
    def __init__(self, path):
        """
        `path` should represent a valid vhost file that has a Listen directive
        in it. This constructor will scan the vhost file for VirtualHosts and populate
        its name_and_alias_directives attribute based on it.

        Raises a ValueError if no port number is found
        """
        self.path = path
        self.port = None
        self.name = os.path.basename(path)
        self.name_and_alias_directives = []
        self.ssl = True

        try:
            # open the vhost, look for the listen directive and any ServerName, and ServerAlias directives
            vhost = open(self.path, 'r')
        except IOError as e:
            if e.errno == errno.EACCES:
                print("Permission error encountered while accessing '%s'" % (VHOST_DIR))
            raise
        else:
            for line in vhost:
                line = line.strip()
                if line.lower().startswith("listen"):
                    self.port = int(re.search(r"(\d+)", line).group(0))

                matches = re.search(r"^\s*(ServerName|ServerAlias)", line, re.IGNORECASE)
                if matches:
                    self.name_and_alias_directives.append(line)

                # we use a little hint in the vhost file to indicate if SSL
                # should be used for this vhost
                if line == "#nossl":
                    self.ssl = False

            if self.port is None: 
                raise ValueError("The vhost %s did not specify a port number! Hint: Use the Listen directive." % self.path)

    def to_proxy_vhost(self):
        """Return a <VirtualHost> as a string that can be used to proxy to this vhost"""
        proxy_vhost_params = {
            "port": self.port,
            "directives": "\n        ".join(self.name_and_alias_directives)
        }
        template = VHOST_PROXY_TEMPLATE_HTTPS if self.ssl else VHOST_PROXY_TEMPLATE_HTTP
        return template % proxy_vhost_params


if __name__ == "__main__":
    # this is a list of strings that will ultimately be joined together to create the proxy vhost
    proxy_vhosts = []
    # this holds all the VhostFile instances that are created
    vhost_files = []
    # maps a port number to a vhost file path so we can detect port number collisions
    ports = {}

    if not os.path.exists(VHOST_DIR):
        print("Virtual host directory '%s' does not exist." % (VHOST_DIR))
        exit(1)

    # scan all the vhost files, and construct VhostFile instances out of them
    for filename in os.listdir(VHOST_DIR):
        # ignore non-.vhost files
        if not filename.endswith(VHOST_SUFFIX):
            continue

        vhost_path = os.path.join(VHOST_DIR, filename)

        try:
            vhost_file = VHostFile(path=vhost_path)
            # make sure the port isn't already in use by another vhost
            if vhost_file.port in ports:
                raise ValueError("Port collision in %s. The file %s already uses port %d" % (vhost_file.path, ports[vhost_file.port], vhost_file.port))
            # keep track of the port that was used by this vhost file
            ports[vhost_file.port] = vhost_file.path
            vhost_files.append(vhost_file)
        except Exception as e:
            print(e)
            print("Error encountered while processing '%s'. Skipping." % (vhost_path))

    if len(sys.argv) == 1:
        usage_msg = "Usage: %s: [-p|-k [start|restart|graceful|graceful-stop|stop]]" % (sys.argv[0])
        print(usage_msg)
        exit(0)
    # print an available port number if there are no arguments
    elif len(sys.argv) == 2 and sys.argv[1] == '-p':
        port = VHOST_PROXY_PORT_START
        while port in ports:
            port += 1
        print(port)
        exit(0)

    # record a set of all the pid files we've created, so we know which ones *not* to
    # clean up later
    pid_files = set()
    # spawn off an apache proc for every vhost file
    for vhost_file in vhost_files:
        pid_file = os.path.join(PID_DIR, "%s-%s.pid" % (IDENTIFIER, vhost_file.name))
        pid_files.add(pid_file)
        cmd = [
            HTTPD, 
            "-Dhttpdmulti",
            "-C", 'User apache',
            "-C", 'Group apache',
            "-c", 'Include %s' % vhost_file.path,
            "-c", 'PidFile %s' % pid_file,
        ] + sys.argv[1:]
        print(subprocess.list2cmdline(cmd))
        code = subprocess.call(cmd) 

        proxy_vhosts.append(vhost_file.to_proxy_vhost())
   
    # now create a vhost file that combines all the proxy vhosts we created
    with open(os.path.join(VHOST_DIR, PROXY_VHOST_NAME), "w") as f:
        f.write("# This is generated. Do not edit. See httpd-multi script\n")
        f.write("\n".join(proxy_vhosts))

    # run the command first using the base httpd process
    cmd = [HTTPD] + sys.argv[1:]
    print(subprocess.list2cmdline(cmd))
    subprocess.call(cmd)
    
    print("Cleaning up...this may take a while")
    cleanup(excluding=pid_files)
